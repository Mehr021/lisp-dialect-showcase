#+TITLE: Lisp Dialect Showcase
#+AUTHOR: Jason Walsh <j@wal.sh>
#+DATE: April 14, 2025
#+PROPERTY: header-args :padline yes :comments both
#+OPTIONS: toc:3 num:t 

* Introduction

This repository contains implementations of common programming problems in various Lisp dialects.
Each implementation demonstrates the unique features and syntax of that particular Lisp variant.

* Problems

We showcase the following small programs in each Lisp dialect:

1. Fibonacci sequence
2. Factorial calculation
3. Prime number generation
4. FizzBuzz
5. Quicksort implementation

* Common Lisp

** Fibonacci

#+BEGIN_SRC lisp :tangle src/common-lisp/fibonacci.lisp :mkdirp yes
(defpackage :cl-fibonacci
  (:use :cl)
  (:export :fib-recursive :fib-iterative :fib-memo))

(in-package :cl-fibonacci)

;; Recursive implementation
(defun fib-recursive (n)
  "Calculate the nth Fibonacci number recursively."
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (t (+ (fib-recursive (- n 1))
              (fib-recursive (- n 2))))))

;; Iterative implementation
(defun fib-iterative (n)
  "Calculate the nth Fibonacci number iteratively."
  (if (< n 2)
      n
      (let ((a 0) (b 1))
        (dotimes (i (- n 1) b)
          (let ((temp (+ a b)))
            (setf a b)
            (setf b temp))))))

;; Memoization implementation
(let ((memo (make-hash-table)))
  (defun fib-memo (n)
    "Calculate the nth Fibonacci number using memoization."
    (or (gethash n memo)
        (setf (gethash n memo)
              (if (< n 2)
                  n
                  (+ (fib-memo (- n 1))
                     (fib-memo (- n 2))))))))

;; Example usage
(defun run-examples ()
  (format t "Fibonacci of 10 (recursive): ~a~%" (fib-recursive 10))
  (format t "Fibonacci of 10 (iterative): ~a~%" (fib-iterative 10))
  (format t "Fibonacci of 10 (memoized): ~a~%" (fib-memo 10)))
#+END_SRC

** Factorial

#+BEGIN_SRC lisp :tangle src/common-lisp/factorial.lisp :mkdirp yes
(defpackage :cl-factorial
  (:use :cl)
  (:export :factorial-recursive :factorial-iterative :factorial-tail))

(in-package :cl-factorial)

;; Recursive implementation
(defun factorial-recursive (n)
  "Calculate factorial recursively."
  (if (<= n 1)
      1
      (* n (factorial-recursive (- n 1)))))

;; Iterative implementation
(defun factorial-iterative (n)
  "Calculate factorial iteratively."
  (let ((result 1))
    (dotimes (i n result)
      (setf result (* result (1+ i))))))

;; Tail-recursive implementation
(defun factorial-tail (n &optional (acc 1))
  "Calculate factorial using tail recursion."
  (if (<= n 1)
      acc
      (factorial-tail (- n 1) (* acc n))))

;; Example usage
(defun run-examples ()
  (format t "Factorial of 5 (recursive): ~a~%" (factorial-recursive 5))
  (format t "Factorial of 5 (iterative): ~a~%" (factorial-iterative 5))
  (format t "Factorial of 5 (tail-recursive): ~a~%" (factorial-tail 5)))
#+END_SRC

** Prime Number Generator

#+BEGIN_SRC lisp :tangle src/common-lisp/primes.lisp :mkdirp yes
(defpackage :cl-primes
  (:use :cl)
  (:export :primep :sieve-of-eratosthenes :primes-up-to))

(in-package :cl-primes)

;; Function to check if a number is prime
(defun primep (n)
  "Check if n is a prime number."
  (when (> n 1)
    (loop for i from 2 to (isqrt n)
          never (zerop (mod n i)))))

;; Sieve of Eratosthenes implementation
(defun sieve-of-eratosthenes (max)
  "Generate all primes up to max using Sieve of Eratosthenes."
  (let ((sieve (make-array (1+ max) :initial-element t)))
    (setf (aref sieve 0) nil
          (aref sieve 1) nil)
    (loop for i from 2 to (isqrt max)
          when (aref sieve i)
          do (loop for j from (* i i) to max by i
                   do (setf (aref sieve j) nil)))
    (loop for i from 2 to max
          when (aref sieve i)
          collect i)))

;; Function to generate primes up to n
(defun primes-up-to (n)
  "Generate a list of primes up to n."
  (loop for i from 2 to n
        when (primep i)
        collect i))

;; Example usage
(defun run-examples ()
  (format t "Primes up to 20: ~a~%" (primes-up-to 20))
  (format t "Primes up to 20 (sieve): ~a~%" (sieve-of-eratosthenes 20))
  (format t "Is 17 prime? ~a~%" (primep 17))
  (format t "Is 15 prime? ~a~%" (primep 15)))
#+END_SRC

** FizzBuzz

#+BEGIN_SRC lisp :tangle src/common-lisp/fizzbuzz.lisp :mkdirp yes
(defpackage :cl-fizzbuzz
  (:use :cl)
  (:export :fizzbuzz))

(in-package :cl-fizzbuzz)

;; FizzBuzz implementation
(defun fizzbuzz (n)
  "Print FizzBuzz from 1 to n."
  (loop for i from 1 to n
        do (format t "~a~%"
                  (cond ((zerop (mod i 15)) "FizzBuzz")
                        ((zerop (mod i 3)) "Fizz")
                        ((zerop (mod i 5)) "Buzz")
                        (t i)))))

;; Functional implementation returning a list
(defun fizzbuzz-list (n)
  "Return a list of FizzBuzz values from 1 to n."
  (loop for i from 1 to n
        collect (cond ((zerop (mod i 15)) "FizzBuzz")
                     ((zerop (mod i 3)) "Fizz")
                     ((zerop (mod i 5)) "Buzz")
                     (t i))))

;; Example usage
(defun run-examples ()
  (format t "FizzBuzz (1-20):~%")
  (fizzbuzz 20)
  (format t "~%FizzBuzz as list (1-20): ~a~%" (fizzbuzz-list 20)))
#+END_SRC

** Quicksort

#+BEGIN_SRC lisp :tangle src/common-lisp/quicksort.lisp :mkdirp yes
(defpackage :cl-quicksort
  (:use :cl)
  (:export :quicksort :quicksort-functional))

(in-package :cl-quicksort)

;; Functional implementation of quicksort
(defun quicksort-functional (list)
  "Sort a list using functional quicksort."
  (if (or (null list) (null (cdr list)))
      list
      (let* ((pivot (car list))
             (rest (cdr list))
             (lesser (remove-if-not (lambda (x) (< x pivot)) rest))
             (greater (remove-if-not (lambda (x) (>= x pivot)) rest)))
        (append (quicksort-functional lesser)
                (list pivot)
                (quicksort-functional greater)))))

;; Destructive in-place quicksort
(defun quicksort (sequence &key (start 0) (end (length sequence)) (predicate #'<))
  "Sort a sequence in-place using quicksort."
  (when (> (- end start) 1)
    (let ((pivot-pos (partition sequence start end predicate)))
      (quicksort sequence :start start :end pivot-pos :predicate predicate)
      (quicksort sequence :start (1+ pivot-pos) :end end :predicate predicate)))
  sequence)

;; Helper function for in-place quicksort
(defun partition (sequence start end predicate)
  (let ((pivot (elt sequence start))
        (i (1+ start)))
    (loop for j from (1+ start) below end
          when (funcall predicate (elt sequence j) pivot)
          do (progn
               (rotatef (elt sequence i) (elt sequence j))
               (incf i)))
    (rotatef (elt sequence start) (elt sequence (1- i)))
    (1- i)))

;; Example usage
(defun run-examples ()
  (let ((list1 '(3 1 4 1 5 9 2 6 5 3 5))
        (list2 '(3 1 4 1 5 9 2 6 5 3 5))
        (vector1 #(3 1 4 1 5 9 2 6 5 3 5)))
    (format t "Original list: ~a~%" list1)
    (format t "Functional quicksort: ~a~%" (quicksort-functional list1))
    (format t "Original list unchanged: ~a~%" list1)
    (format t "Destructive quicksort (list): ~a~%" (quicksort list2))
    (format t "Destructive quicksort (vector): ~a~%" (quicksort vector1))))
#+END_SRC

* Clojure

** Fibonacci

#+BEGIN_SRC clojure :tangle src/clojure/fibonacci.clj :mkdirp yes
(ns clojure.fibonacci
  (:gen-class))

;; Recursive implementation
(defn fib-recursive [n]
  (cond 
    (= n 0) 0
    (= n 1) 1
    :else (+ (fib-recursive (- n 1))
             (fib-recursive (- n 2)))))

;; Lazy sequence implementation
(def fibs
  (lazy-cat [0 1] (map + fibs (rest fibs))))

(defn fib-lazy [n]
  (nth fibs n))

;; Tail-recursive implementation
(defn fib-tail
  ([n] (fib-tail n 0 1))
  ([n a b]
   (if (zero? n)
     a
     (recur (dec n) b (+ a b)))))

;; Example usage
(defn run-examples []
  (println "Fibonacci of 10 (recursive):" (fib-recursive 10))
  (println "Fibonacci of 10 (lazy):" (fib-lazy 10))
  (println "Fibonacci of 10 (tail):" (fib-tail 10))
  (println "First 10 Fibonacci numbers:" (take 10 fibs)))

(defn -main []
  (run-examples))
#+END_SRC

** Factorial

#+BEGIN_SRC clojure :tangle src/clojure/factorial.clj :mkdirp yes
(ns clojure.factorial
  (:gen-class))

;; Recursive implementation
(defn factorial-recursive [n]
  (if (<= n 1)
    1
    (* n (factorial-recursive (dec n)))))

;; Tail-recursive implementation
(defn factorial-tail
  ([n] (factorial-tail n 1))
  ([n acc]
   (if (<= n 1)
     acc
     (recur (dec n) (* acc n)))))

;; Using reduce
(defn factorial-reduce [n]
  (reduce * (range 1 (inc n))))

;; Example usage
(defn run-examples []
  (println "Factorial of 5 (recursive):" (factorial-recursive 5))
  (println "Factorial of 5 (tail):" (factorial-tail 5))
  (println "Factorial of 5 (reduce):" (factorial-reduce 5)))

(defn -main []
  (run-examples))
#+END_SRC

** Prime Number Generator

#+BEGIN_SRC clojure :tangle src/clojure/primes.clj :mkdirp yes
(ns clojure.primes
  (:gen-class))

;; Check if a number is prime
(defn prime? [n]
  (cond
    (<= n 1) false
    (= n 2) true
    (even? n) false
    :else (not-any? #(zero? (mod n %))
                    (range 3 (inc (Math/sqrt n)) 2))))

;; Sieve of Eratosthenes
(defn sieve-of-eratosthenes [n]
  (let [n (int n)]
    (if (<= n 1)
      []
      (let [sqrt-n (int (Math/sqrt n))
            sieve (boolean-array (inc n) true)]
        (aset sieve 0 false)
        (aset sieve 1 false)
        (doseq [i (range 2 (inc sqrt-n))]
          (when (aget sieve i)
            (doseq [j (range (* i i) (inc n) i)]
              (aset sieve j false))))
        (filter #(aget sieve %) (range 2 (inc n)))))))

;; Generate primes up to n
(defn primes-up-to [n]
  (filter prime? (range 2 (inc n))))

;; Example usage
(defn run-examples []
  (println "Primes up to 20:" (primes-up-to 20))
  (println "Primes up to 20 (sieve):" (sieve-of-eratosthenes 20))
  (println "Is 17 prime?" (prime? 17))
  (println "Is 15 prime?" (prime? 15)))

(defn -main []
  (run-examples))
#+END_SRC

** FizzBuzz

#+BEGIN_SRC clojure :tangle src/clojure/fizzbuzz.clj :mkdirp yes
(ns clojure.fizzbuzz
  (:gen-class))

;; FizzBuzz using cond
(defn fizzbuzz-cond [n]
  (map (fn [i]
         (cond
           (zero? (mod i 15)) "FizzBuzz"
           (zero? (mod i 3)) "Fizz"
           (zero? (mod i 5)) "Buzz"
           :else i))
       (range 1 (inc n))))

;; FizzBuzz using pattern matching
(defn fizzbuzz-match [n]
  (for [i (range 1 (inc n))]
    (condp #(zero? (mod %2 %1)) i
      15 "FizzBuzz"
      3 "Fizz"
      5 "Buzz"
      i)))

;; FizzBuzz using case with remainder vector
(defn fizzbuzz-case [n]
  (for [i (range 1 (inc n))
        :let [div3 (zero? (mod i 3))
              div5 (zero? (mod i 5))]]
    (case [div3 div5]
      [true true] "FizzBuzz"
      [true false] "Fizz"
      [false true] "Buzz"
      i)))

;; Example usage
(defn run-examples []
  (println "FizzBuzz (1-20) using cond:")
  (doseq [item (fizzbuzz-cond 20)]
    (println item))
  (println "\nFizzBuzz (1-20) using pattern matching:")
  (println (fizzbuzz-match 20)))

(defn -main []
  (run-examples))
#+END_SRC

** Quicksort

#+BEGIN_SRC clojure :tangle src/clojure/quicksort.clj :mkdirp yes
(ns clojure.quicksort
  (:gen-class))

;; Functional implementation of quicksort
(defn quicksort [coll]
  (if (empty? coll)
    []
    (let [pivot (first coll)
          rest-coll (rest coll)]
      (concat (quicksort (filter #(< % pivot) rest-coll))
              [pivot]
              (quicksort (filter #(>= % pivot) rest-coll))))))

;; Using partition
(defn quicksort-partition [coll]
  (if (or (empty? coll) (= 1 (count coll)))
    coll
    (let [pivot (first coll)
          parts (group-by #(compare % pivot) (rest coll))]
      (concat (quicksort-partition (get parts -1 []))
              [pivot]
              (quicksort-partition (get parts 1 []))
              (quicksort-partition (get parts 0 []))))))

;; Example usage
(defn run-examples []
  (let [numbers [3 1 4 1 5 9 2 6 5 3 5]]
    (println "Original collection:" numbers)
    (println "Quicksort:" (quicksort numbers))
    (println "Quicksort with partition:" (quicksort-partition numbers))))

(defn -main []
  (run-examples))
#+END_SRC

* Scheme

** Fibonacci

#+BEGIN_SRC scheme :tangle src/scheme/fibonacci.scm :mkdirp yes
;; Recursive implementation
(define (fib-recursive n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib-recursive (- n 1))
                (fib-recursive (- n 2))))))

;; Tail-recursive implementation
(define (fib-tail n)
  (define (fib-iter a b count)
    (if (= count 0)
        a
        (fib-iter b (+ a b) (- count 1))))
  (fib-iter 0 1 n))

;; Continuation-passing style
(define (fib-cps n k)
  (cond ((= n 0) (k 0))
        ((= n 1) (k 1))
        (else (fib-cps (- n 1)
                      (lambda (v1)
                        (fib-cps (- n 2)
                               (lambda (v2)
                                 (k (+ v1 v2)))))))))

(define (fib n)
  (fib-cps n (lambda (x) x)))

;; Example usage
(define (run-examples)
  (display "Fibonacci of 10 (recursive): ")
  (display (fib-recursive 10))
  (newline)
  (display "Fibonacci of 10 (tail-recursive): ")
  (display (fib-tail 10))
  (newline)
  (display "Fibonacci of 10 (CPS): ")
  (display (fib 10))
  (newline))

(run-examples)
#+END_SRC

** Factorial

#+BEGIN_SRC scheme :tangle src/scheme/factorial.scm :mkdirp yes
;; Recursive implementation
(define (factorial-recursive n)
  (if (<= n 1)
      1
      (* n (factorial-recursive (- n 1)))))

;; Tail-recursive implementation
(define (factorial-tail n)
  (define (fact-iter product counter max-count)
    (if (> counter max-count)
        product
        (fact-iter (* counter product)
                  (+ counter 1)
                  max-count)))
  (fact-iter 1 1 n))

;; Example usage
(define (run-examples)
  (display "Factorial of 5 (recursive): ")
  (display (factorial-recursive 5))
  (newline)
  (display "Factorial of 5 (tail-recursive): ")
  (display (factorial-tail 5))
  (newline))

(run-examples)
#+END_SRC

** Prime Number Generator

#+BEGIN_SRC scheme :tangle src/scheme/primes.scm :mkdirp yes
;; Helper function: square root
(define (square x) (* x x))

;; Check if a number is prime
(define (prime? n)
  (define (smallest-divisor n)
    (find-divisor n 2))
  (define (find-divisor n test-divisor)
    (cond ((> (square test-divisor) n) n)
          ((divides? test-divisor n) test-divisor)
          (else (find-divisor n (+ test-divisor 1)))))
  (define (divides? a b)
    (= (remainder b a) 0))
  (and (> n 1) (= n (smallest-divisor n))))

;; Generate primes up to n
(define (primes-up-to n)
  (define (iter i result)
    (cond ((> i n) (reverse result))
          ((prime? i) (iter (+ i 1) (cons i result)))
          (else (iter (+ i 1) result))))
  (iter 2 '()))

;; Sieve of Eratosthenes (using lists)
(define (sieve-of-eratosthenes n)
  (define (sieve numbers)
    (if (null? numbers)
        '()
        (let ((p (car numbers)))
          (cons p (sieve (filter
                         (lambda (x) (not (= 0 (remainder x p))))
                         (cdr numbers)))))))
  (sieve (range 2 n)))

;; Helper: generate a range of numbers
(define (range start end)
  (if (> start end)
      '()
      (cons start (range (+ start 1) end))))

;; Example usage
(define (run-examples)
  (display "Primes up to 20: ")
  (display (primes-up-to 20))
  (newline)
  (display "Primes up to 20 (sieve): ")
  (display (sieve-of-eratosthenes 21))
  (newline)
  (display "Is 17 prime? ")
  (display (prime? 17))
  (newline)
  (display "Is 15 prime? ")
  (display (prime? 15))
  (newline))

(run-examples)
#+END_SRC

** FizzBuzz

#+BEGIN_SRC scheme :tangle src/scheme/fizzbuzz.scm :mkdirp yes
;; Helper: display FizzBuzz for a number
(define (fizzbuzz-number n)
  (cond ((= (remainder n 15) 0) "FizzBuzz")
        ((= (remainder n 3) 0) "Fizz")
        ((= (remainder n 5) 0) "Buzz")
        (else n)))

;; Print FizzBuzz sequence
(define (fizzbuzz n)
  (define (iter i)
    (when (<= i n)
      (display (fizzbuzz-number i))
      (newline)
      (iter (+ i 1))))
  (iter 1))

;; Create a list of FizzBuzz values
(define (fizzbuzz-list n)
  (define (iter i result)
    (if (> i n)
        (reverse result)
        (iter (+ i 1) (cons (fizzbuzz-number i) result))))
  (iter 1 '()))

;; Example usage
(define (run-examples)
  (display "FizzBuzz (1-20):\n")
  (fizzbuzz 20)
  (display "\nFizzBuzz as list (1-20): ")
  (display (fizzbuzz-list 20))
  (newline))

(run-examples)
#+END_SRC

** Quicksort

#+BEGIN_SRC scheme :tangle src/scheme/quicksort.scm :mkdirp yes
;; Quicksort implementation
(define (quicksort lst)
  (if (or (null? lst) (null? (cdr lst)))
      lst
      (let ((pivot (car lst))
            (rest (cdr lst)))
        (append (quicksort (filter (lambda (x) (< x pivot)) rest))
                (list pivot)
                (quicksort (filter (lambda (x) (>= x pivot)) rest))))))

;; Helper: filter a list
(define (filter pred lst)
  (cond ((null? lst) '())
        ((pred (car lst))
         (cons (car lst) (filter pred (cdr lst))))
        (else (filter pred (cdr lst)))))

;; Example usage
(define (run-examples)
  (let ((numbers '(3 1 4 1 5 9 2 6 5 3 5)))
    (display "Original list: ")
    (display numbers)
    (newline)
    (display "Sorted list: ")
    (display (quicksort numbers))
    (newline)))

(run-examples)
#+END_SRC

* Emacs Lisp

** Fibonacci

#+BEGIN_SRC elisp :tangle src/emacs-lisp/fibonacci.el :mkdirp yes
;;; fibonacci.el --- Fibonacci implementations in Emacs Lisp

;;; Commentary:
;; Various implementations of the Fibonacci sequence in Emacs Lisp

;;; Code:

;; Recursive implementation
(defun fib-recursive (n)
  "Calculate the Nth Fibonacci number recursively."
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (t (+ (fib-recursive (- n 1))
              (fib-recursive (- n 2))))))

;; Dynamic programming implementation
(defun fib-dp (n)
  "Calculate the Nth Fibonacci number using dynamic programming."
  (let ((fib-table (make-vector (1+ n) nil)))
    (aset fib-table 0 0)
    (when (> n 0)
      (aset fib-table 1 1)
      (dotimes (i (- n 1))
        (aset fib-table (+ i 2)
              (+ (aref fib-table (+ i 1))
                 (aref fib-table i)))))
    (aref fib-table n)))

;; Memoization using lexical closure
(defun fib-memo-func ()
  "Create a memoized Fibonacci function."
  (let ((memo (make-hash-table)))
    (puthash 0 0 memo)
    (puthash 1 1 memo)
    (lambda (n)
      (or (gethash n memo)
          (puthash n
                   (+ (funcall this (- n 1))
                      (funcall this (- n 2)))
                   memo)))))

(defvar fib-memo (fib-memo-func)
  "Memoized Fibonacci function.")

;; Example usage
(defun run-fibonacci-examples ()
  "Run examples of various Fibonacci implementations."
  (message "Fibonacci of 10 (recursive): %d" (fib-recursive 10))
  (message "Fibonacci of 10 (dynamic programming): %d" (fib-dp 10))
  (message "Fibonacci of 10 (memoized): %d" (funcall fib-memo 10)))

(provide 'fibonacci)
;;; fibonacci.el ends here
#+END_SRC

** Factorial

#+BEGIN_SRC elisp :tangle src/emacs-lisp/factorial.el :mkdirp yes
;;; factorial.el --- Factorial implementations in Emacs Lisp

;;; Commentary:
;; Various implementations of factorial calculation in Emacs Lisp

;;; Code:

;; Recursive implementation
(defun factorial-recursive (n)
  "Calculate factorial of N recursively."
  (if (<= n 1)
      1
    (* n (factorial-recursive (- n 1)))))

;; Iterative implementation
(defun factorial-iterative (n)
  "Calculate factorial of N iteratively."
  (let ((result 1))
    (dotimes (i n result)
      (setq result (* result (1+ i))))))

;; Tail-recursive implementation
(defun factorial-tail (n &optional (acc 1))
  "Calculate factorial of N using tail recursion with accumulator ACC."
  (if (<= n 1)
      acc
    (factorial-tail (1- n) (* acc n))))

;; Example usage
(defun run-factorial-examples ()
  "Run examples of various factorial implementations."
  (message "Factorial of 5 (recursive): %d" (factorial-recursive 5))
  (message "Factorial of 5 (iterative): %d" (factorial-iterative 5))
  (message "Factorial of 5 (tail-recursive): %d" (factorial-tail 5)))

(provide 'factorial)
;;; factorial.el ends here
#+END_SRC

** Prime Number Generator

#+BEGIN_SRC elisp :tangle src/emacs-lisp/primes.el :mkdirp yes
;;; primes.el --- Prime number functions in Emacs Lisp

;;; Commentary:
;; Functions for working with prime numbers in Emacs Lisp

;;; Code:

;; Check if a number is prime
(defun primep (n)
  "Check if N is a prime number."
  (when (> n 1)
    (let ((limit (isqrt n))
          (is-prime t)
          (divisor 2))
      (while (and is-prime (<= divisor limit))
        (when (= (mod n divisor) 0)
          (setq is-prime nil))
        (setq divisor (1+ divisor)))
      is-prime)))

;; Generate primes up to n
(defun primes-up-to (n)
  "Generate a list of primes up to N."
  (let ((result nil))
    (dotimes (i n)
      (let ((num (1+ i)))
        (when (primep num)
          (push num result))))
    (nreverse result)))

;; Sieve of Eratosthenes
(defun sieve-of-eratosthenes (n)
  "Generate primes up to N using the Sieve of Eratosthenes."
  (let ((sieve (make-bool-vector (1+ n) t)))
    ;; 0 and 1 are not prime
    (aset sieve 0 nil)
    (aset sieve 1 nil)
    ;; Mark multiples of each prime as non-prime
    (let ((limit (isqrt n)))
      (dotimes (i limit)
        (let ((num (+ i 2)))
          (when (aref sieve num)
            (let ((j (* num num)))
              (while (<= j n)
                (aset sieve j nil)
                (setq j (+ j num))))))))
    ;; Collect the primes
    (let ((primes nil))
      (dotimes (i (1- n))
        (let ((num (+ i 2)))
          (when (aref sieve num)
            (push num primes))))
      (nreverse primes))))

;; Example usage
(defun run-prime-examples ()
  "Run examples of prime number functions."
  (message "Primes up to 20: %S" (primes-up-to 20))
  (message "Primes up to 20 (sieve): %S" (sieve-of-eratosthenes 20))
  (message "Is 17 prime? %s" (if (primep 17) "Yes" "No"))
  (message "Is 15 prime? %s" (if (primep 15) "Yes" "No")))

(provide 'primes)
;;; primes.el ends here
#+END_SRC

** FizzBuzz

#+BEGIN_SRC elisp :tangle src/emacs-lisp/fizzbuzz.el :mkdirp yes
;;; fizzbuzz.el --- FizzBuzz implementation in Emacs Lisp

;;; Commentary:
;; FizzBuzz implementation in Emacs Lisp

;;; Code:

;; FizzBuzz implementation
(defun fizzbuzz (n)
  "Print FizzBuzz from 1 to N."
  (dotimes (i n)
    (let ((num (1+ i)))
      (message "%s"
               (cond
                ((zerop (mod num 15)) "FizzBuzz")
                ((zerop (mod num 3)) "Fizz")
                ((zerop (mod num 5)) "Buzz")
                (t num))))))

;; Function to return a list of FizzBuzz values
(defun fizzbuzz-list (n)
  "Return a list of FizzBuzz values from 1 to N."
  (let ((result nil))
    (dotimes (i n)
      (let ((num (1+ i)))
        (push
         (cond
          ((zerop (mod num 15)) "FizzBuzz")
          ((zerop (mod num 3)) "Fizz")
          ((zerop (mod num 5)) "Buzz")
          (t num))
         result)))
    (nreverse result)))

;; Example usage
(defun run-fizzbuzz-examples ()
  "Run examples of FizzBuzz functions."
  (message "FizzBuzz (1-20):")
  (fizzbuzz 20)
  (message "\nFizzBuzz as list (1-20): %S" (fizzbuzz-list 20)))

(provide 'fizzbuzz)
;;; fizzbuzz.el ends here
#+END_SRC

** Quicksort

#+BEGIN_SRC elisp :tangle src/emacs-lisp/quicksort.el :mkdirp yes
;;; quicksort.el --- Quicksort implementation in Emacs Lisp

;;; Commentary:
;; Quicksort implementation in Emacs Lisp

;;; Code:

;; Quicksort implementation for lists
(defun quicksort-list (list)
  "Sort LIST using quicksort algorithm."
  (if (or (null list) (null (cdr list)))
      list
    (let* ((pivot (car list))
           (rest (cdr list))
           (lesser (cl-remove-if-not (lambda (x) (< x pivot)) rest))
           (greater (cl-remove-if-not (lambda (x) (>= x pivot)) rest)))
      (append (quicksort-list lesser)
              (list pivot)
              (quicksort-list greater)))))

;; Quicksort implementation for vectors
(defun quicksort-vector (vec &optional start end)
  "Sort vector VEC in-place using quicksort from START to END."
  (let ((start (or start 0))
        (end (or end (length vec))))
    (when (> (- end start) 1)
      (let ((pivot-pos (partition vec start end)))
        (quicksort-vector vec start pivot-pos)
        (quicksort-vector vec (1+ pivot-pos) end)))
    vec))

;; Helper function for vector quicksort
(defun partition (vec start end)
  "Partition vector VEC from START to END and return pivot position."
  (let* ((pivot (aref vec start))
         (i (1+ start)))
    (cl-loop for j from (1+ start) below end
             when (< (aref vec j) pivot)
             do (progn
                  (cl-rotatef (aref vec i) (aref vec j))
                  (setq i (1+ i))))
    (cl-rotatef (aref vec start) (aref vec (1- i)))
    (1- i)))

;; Example usage
(defun run-quicksort-examples ()
  "Run examples of quicksort functions."
  (let ((list1 '(3 1 4 1 5 9 2 6 5 3 5))
        (vec1 [3 1 4 1 5 9 2 6 5 3 5]))
    (message "Original list: %S" list1)
    (message "Sorted list: %S" (quicksort-list list1))
    (message "Original vector: %S" vec1)
    (message "Sorted vector: %S" (quicksort-vector (copy-sequence vec1)))))

(provide 'quicksort)
;;; quicksort.el ends here
#+END_SRC

* Racket

** Fibonacci

#+BEGIN_SRC racket :tangle src/racket/fibonacci.rkt :mkdirp yes
#lang racket

;; Recursive implementation
(define (fib-recursive n)
  (cond [(= n 0) 0]
        [(= n 1) 1]
        [else (+ (fib-recursive (- n 1))
                 (fib-recursive (- n 2)))]))

;; Memoization with built-in support
(require racket/memoize)

(define fib-memo
  (memoize
   (λ (n)
     (cond [(= n 0) 0]
           [(= n 1) 1]
           [else (+ (fib-memo (- n 1))
                    (fib-memo (- n 2)))]))))

;; Contract-based implementation
(provide/contract
 [fibonacci (-> exact-nonnegative-integer?
                exact-nonnegative-integer?)])

(define (fibonacci n)
  (cond [(= n 0) 0]
        [(= n 1) 1]
        [else (+ (fibonacci (- n 1))
                 (fibonacci (- n 2)))]))

;; Example usage
(define (run-examples)
  (displayln (format "Fibonacci of 10 (recursive): ~a" (fib-recursive 10)))
  (displayln (format "Fibonacci of 10 (memoized): ~a" (fib-memo 10)))
  (displayln (format "Fibonacci of 10 (contract): ~a" (fibonacci 10))))

(module+ main
  (run-examples))
#+END_SRC

** Factorial

#+BEGIN_SRC racket :tangle src/racket/factorial.rkt :mkdirp yes
#lang racket

;; Recursive implementation
(define (factorial-recursive n)
  (if (<= n 1)
      1
      (* n (factorial-recursive (- n 1)))))

;; Tail-recursive implementation
(define (factorial-tail n [acc 1])
  (if (<= n 1)
      acc
      (factorial-tail (- n 1) (* n acc))))

;; Implementation using fold
(define (factorial-fold n)
  (for/fold ([acc 1])
            ([i (in-range 1 (add1 n))])
    (* acc i)))

;; Example usage
(define (run-examples)
  (displayln (format "Factorial of 5 (recursive): ~a" (factorial-recursive 5)))
  (displayln (format "Factorial of 5 (tail): ~a" (factorial-tail 5)))
  (displayln (format "Factorial of 5 (fold): ~a" (factorial-fold 5))))

(module+ main
  (run-examples))
#+END_SRC

** Prime Number Generator

#+BEGIN_SRC racket :tangle src/racket/primes.rkt :mkdirp yes
#lang racket

;; Check if a number is prime
(define (prime? n)
  (and (> n 1)
       (let loop ([i 2])
         (or (> (sqr i) n)
             (and (not (zero? (remainder n i)))
                  (loop (add1 i)))))))

;; Generate primes up to n
(define (primes-up-to n)
  (for/list ([i (in-range 2 (add1 n))]
             #:when (prime? i))
    i))

;; Sieve of Eratosthenes
(define (sieve-of-eratosthenes n)
  (define sieve (make-vector (add1 n) #t))
  (vector-set! sieve 0 #f)
  (vector-set! sieve 1 #f)
  
  (for ([i (in-range 2 (add1 (exact-floor (sqrt n))))]
        #:when (vector-ref sieve i))
    (for ([j (in-range (sqr i) (add1 n) i)])
      (vector-set! sieve j #f)))
  
  (for/list ([i (in-range 2 (add1 n))]
             #:when (vector-ref sieve i))
    i))

;; Example usage
(define (run-examples)
  (displayln (format "Primes up to 20: ~a" (primes-up-to 20)))
  (displayln (format "Primes up to 20 (sieve): ~a" (sieve-of-eratosthenes 20)))
  (displayln (format "Is 17 prime? ~a" (prime? 17)))
  (displayln (format "Is 15 prime? ~a" (prime? 15))))

(module+ main
  (run-examples))
#+END_SRC

** FizzBuzz

#+BEGIN_SRC racket :tangle src/racket/fizzbuzz.rkt :mkdirp yes
#lang racket

;; FizzBuzz using cond
(define (fizzbuzz n)
  (for ([i (in-range 1 (add1 n))])
    (displayln
     (cond
       [(zero? (remainder i 15)) "FizzBuzz"]
       [(zero? (remainder i 3)) "Fizz"]
       [(zero? (remainder i 5)) "Buzz"]
       [else i]))))

;; FizzBuzz as a list using for/list
(define (fizzbuzz-list n)
  (for/list ([i (in-range 1 (add1 n))])
    (cond
      [(zero? (remainder i 15)) "FizzBuzz"]
      [(zero? (remainder i 3)) "Fizz"]
      [(zero? (remainder i 5)) "Buzz"]
      [else i])))

;; FizzBuzz using match
(define (fizzbuzz-match n)
  (for/list ([i (in-range 1 (add1 n))])
    (match (list (zero? (remainder i 3))
                (zero? (remainder i 5)))
      [(list #t #t) "FizzBuzz"]
      [(list #t #f) "Fizz"]
      [(list #f #t) "Buzz"]
      [_ i])))

;; Example usage
(define (run-examples)
  (displayln "FizzBuzz (1-20):")
  (fizzbuzz 20)
  (displayln (format "\nFizzBuzz as list (1-20): ~a" (fizzbuzz-list 20))))

(module+ main
  (run-examples))
#+END_SRC

** Quicksort

#+BEGIN_SRC racket :tangle src/racket/quicksort.rkt :mkdirp yes
#lang racket

;; Quicksort implementation using filter
(define (quicksort lst)
  (if (or (empty? lst) (empty? (rest lst)))
      lst
      (let ([pivot (first lst)]
            [rest (rest lst)])
        (append
         (quicksort (filter (λ (x) (< x pivot)) rest))
         (list pivot)
         (quicksort (filter (λ (x) (>= x pivot)) rest))))))

;; Quicksort using Racket's pattern matching
(define (quicksort-match lst)
  (match lst
    [(list) '()]
    [(list x) (list x)]
    [(cons pivot rest)
     (append
      (quicksort-match (filter (λ (x) (< x pivot)) rest))
      (list pivot)
      (quicksort-match (filter (λ (x) (>= x pivot)) rest)))]))

;; Quicksort using for/list
(define (quicksort-for lst)
  (if (or (empty? lst) (empty? (rest lst)))
      lst
      (let ([pivot (first lst)]
            [rest (rest lst)])
        (append
         (quicksort-for
          (for/list ([x rest] #:when (< x pivot)) x))
         (list pivot)
         (quicksort-for
          (for/list ([x rest] #:when (>= x pivot)) x))))))

;; Example usage
(define (run-examples)
  (let ([numbers '(3 1 4 1 5 9 2 6 5 3 5)])
    (displayln (format "Original list: ~a" numbers))
    (displayln (format "Quicksort: ~a" (quicksort numbers)))
    (displayln (format "Quicksort with match: ~a" (quicksort-match numbers)))
    (displayln (format "Quicksort with for/list: ~a" (quicksort-for numbers)))))

(module+ main
  (run-examples))
#+END_SRC

* Hy

** Fibonacci

#+BEGIN_SRC hy :tangle src/hy/fibonacci.hy :mkdirp yes
#!/usr/bin/env hy

;; Recursive implementation
(defn fib-recursive [n]
  (cond [(= n 0) 0]
        [(= n 1) 1]
        [True (+ (fib-recursive (- n 1))
                 (fib-recursive (- n 2)))]))

;; Using Python's functionality
(import functools)

(defn fib-memo [n]
  (with-decorator (functools.lru_cache)
    (defn fib [n]
      (if (< n 2)
          n
          (+ (fib (- n 1))
             (fib (- n 2))))))
  (fib n))

;; Generator-based implementation
(defn fib-seq [n]
  (setv a 0)
  (setv b 1)
  (for [_ (range n)]
    (yield a)
    (setv [a b] [(, b (+ a b))]))
  (yield a))

(defn fib-gen [n]
  (list (take (+ n 1) (fib-seq 1000)))[-1])

;; Example usage
(defn run-examples []
  (print f"Fibonacci of 10 (recursive): {(fib-recursive 10)}")
  (print f"Fibonacci of 10 (memoized): {(fib-memo 10)}")
  (print f"Fibonacci of 10 (generator): {(fib-gen 10)}")
  (print f"First 10 Fibonacci numbers: {(list (take 10 (fib-seq 20)))}")
  )

(when (= __name__ "__main__")
  (run-examples))
#+END_SRC

** Factorial

#+BEGIN_SRC hy :tangle src/hy/factorial.hy :mkdirp yes
#!/usr/bin/env hy

;; Recursive implementation
(defn factorial-recursive [n]
  (if (<= n 1)
      1
      (* n (factorial-recursive (- n 1)))))

;; Tail-recursive implementation
(defn factorial-tail [n &optional [acc 1]]
  (if (<= n 1)
      acc
      (factorial-tail (- n 1) (* n acc))))

;; Using Python's functionality
(import math)

(defn factorial-math [n]
  (math.factorial n))

;; Example usage
(defn run-examples []
  (print f"Factorial of 5 (recursive): {(factorial-recursive 5)}")
  (print f"Factorial of 5 (tail-recursive): {(factorial-tail 5)}")
  (print f"Factorial of 5 (math): {(factorial-math 5)}")
  )

(when (= __name__ "__main__")
  (run-examples))
#+END_SRC

** Prime Number Generator

#+BEGIN_SRC hy :tangle src/hy/primes.hy :mkdirp yes
#!/usr/bin/env hy

;; Check if a number is prime
(defn prime? [n]
  (when (> n 1)
    (setv limit (int (math.sqrt n)))
    (for [i (range 2 (+ limit 1))]
      (when (= (% n i) 0)
        (return False)))
    True))

;; Generate primes up to n
(defn primes-up-to [n]
  (lfor i (range 2 (+ n 1)) :if (prime? i) i))

;; Sieve of Eratosthenes
(defn sieve-of-eratosthenes [n]
  (setv sieve (* [True] (+ n 1)))
  (assoc sieve 0 False)
  (assoc sieve 1 False)
  
  (for [i (range 2 (+ (int (math.sqrt n)) 1))]
    (when (get sieve i)
      (for [j (range (* i i) (+ n 1) i)]
        (assoc sieve j False))))
  
  (lfor i (range 2 (+ n 1)) :if (get sieve i) i))

;; Example usage
(import math)

(defn run-examples []
  (print f"Primes up to 20: {(primes-up-to 20)}")
  (print f"Primes up to 20 (sieve): {(sieve-of-eratosthenes 20)}")
  (print f"Is 17 prime? {(prime? 17)}")
  (print f"Is 15 prime? {(prime? 15)}")
  )

(when (= __name__ "__main__")
  (run-examples))
#+END_SRC

** FizzBuzz

#+BEGIN_SRC hy :tangle src/hy/fizzbuzz.hy :mkdirp yes
#!/usr/bin/env hy

;; FizzBuzz implementation
(defn fizzbuzz [n]
  (for [i (range 1 (+ n 1))]
    (print (cond [(= (% i 15) 0) "FizzBuzz"]
                 [(= (% i 3) 0) "Fizz"]
                 [(= (% i 5) 0) "Buzz"]
                 [True i]))))

;; FizzBuzz returning a list
(defn fizzbuzz-list [n]
  (lfor i (range 1 (+ n 1))
        (cond [(= (% i 15) 0) "FizzBuzz"]
              [(= (% i 3) 0) "Fizz"]
              [(= (% i 5) 0) "Buzz"]
              [True i])))

;; Using Python list comprehension style
(defn fizzbuzz-comp [n]
  (lfor i (range 1 (+ n 1))
        (if (= (% i 15) 0) "FizzBuzz"
            (if (= (% i 3) 0) "Fizz"
                (if (= (% i 5) 0) "Buzz" i)))))

;; Example usage
(defn run-examples []
  (print "FizzBuzz (1-20):")
  (fizzbuzz 20)
  (print "\nFizzBuzz as list (1-20):")
  (print (fizzbuzz-list 20))
  )

(when (= __name__ "__main__")
  (run-examples))
#+END_SRC

** Quicksort

#+BEGIN_SRC hy :tangle src/hy/quicksort.hy :mkdirp yes
#!/usr/bin/env hy

;; Quicksort implementation
(defn quicksort [lst]
  (if (or (not lst) (= (len lst) 1))
      lst
      (let [pivot (first lst)
            rest (list (rest lst))]
        (+ (quicksort (lfor x rest :if (< x pivot) x))
           [pivot]
           (quicksort (lfor x rest :if (>= x pivot) x))))))

;; Quicksort using filter
(defn quicksort-filter [lst]
  (if (or (not lst) (= (len lst) 1))
      lst
      (let [pivot (first lst)
            rest (list (rest lst))]
        (+ (quicksort-filter (list (filter (fn [x] (< x pivot)) rest)))
           [pivot]
           (quicksort-filter (list (filter (fn [x] (>= x pivot)) rest)))))))

;; Example usage
(defn run-examples []
  (setv numbers [3 1 4 1 5 9 2 6 5 3 5])
  (print f"Original list: {numbers}")
  (print f"Sorted list: {(quicksort numbers)}")
  (print f"Sorted with filter: {(quicksort-filter numbers)}")
  )

(when (= __name__ "__main__")
  (run-examples))
#+END_SRC

* Fennel

** Fibonacci

#+BEGIN_SRC fennel :tangle src/fennel/fibonacci.fnl :mkdirp yes
;; Recursive implementation
(fn fib-recursive [n]
  (if (= n 0) 0
      (= n 1) 1
      (+ (fib-recursive (- n 1))
         (fib-recursive (- n 2)))))

;; Tail-recursive implementation
(fn fib-tail [n]
  (var [a b] [0 1])
  (for [_ 1 n]
    (set [a b] [b (+ a b)]))
  a)

;; Memoized implementation
(local memo {})

(fn fib-memo [n]
  (if (. memo n)
      (. memo n)
      (let [result (if (< n 2)
                       n
                       (+ (fib-memo (- n 1))
                          (fib-memo (- n 2))))]
        (tset memo n result)
        result)))

;; Example usage
(fn run-examples []
  (print (.. "Fibonacci of 10 (recursive): " (fib-recursive 10)))
  (print (.. "Fibonacci of 10 (tail-recursive): " (fib-tail 10)))
  (print (.. "Fibonacci of 10 (memoized): " (fib-memo 10))))

(run-examples)
#+END_SRC

** Factorial

#+BEGIN_SRC fennel :tangle src/fennel/factorial.fnl :mkdirp yes
;; Recursive implementation
(fn factorial-recursive [n]
  (if (<= n 1)
      1
      (* n (factorial-recursive (- n 1)))))

;; Tail-recursive implementation
(fn factorial-tail [n acc]
  (let [acc (or acc 1)]
    (if (<= n 1)
        acc
        (factorial-tail (- n 1) (* n acc)))))

;; Iterative implementation
(fn factorial-iterative [n]
  (var result 1)
  (for [i 1 n]
    (set result (* result i)))
  result)

;; Example usage
(fn run-examples []
  (print (.. "Factorial of 5 (recursive): " (factorial-recursive 5)))
  (print (.. "Factorial of 5 (tail-recursive): " (factorial-tail 5)))
  (print (.. "Factorial of 5 (iterative): " (factorial-iterative 5))))

(run-examples)
#+END_SRC

** Prime Number Generator

#+BEGIN_SRC fennel :tangle src/fennel/primes.fnl :mkdirp yes
;; Check if a number is prime
(fn is-prime? [n]
  (when (> n 1)
    (var prime? true)
    (let [limit (math.floor (math.sqrt n))]
      (for [i 2 limit 1]
        (when (= (% n i) 0)
          (set prime? false)
          (lua "break")))
      prime?)))

;; Generate primes up to n
(fn primes-up-to [n]
  (local result [])
  (for [i 2 n]
    (when (is-prime? i)
      (table.insert result i)))
  result)

;; Sieve of Eratosthenes
(fn sieve-of-eratosthenes [n]
  (local sieve [])
  ;; Initialize sieve
  (for [i 0 n]
    (tset sieve i true))
  
  ;; 0 and 1 are not prime
  (tset sieve 0 false)
  (tset sieve 1 false)
  
  ;; Mark multiples as non-prime
  (let [limit (math.floor (math.sqrt n))]
    (for [i 2 limit]
      (when (. sieve i)
        (var j (* i i))
        (while (<= j n)
          (tset sieve j false)
          (set j (+ j i))))))
  
  ;; Collect primes
  (local primes [])
  (for [i 2 n]
    (when (. sieve i)
      (table.insert primes i)))
  
  primes)

;; Example usage
(fn run-examples []
  (print "Primes up to 20:")
  (print (table.concat (primes-up-to 20) ", "))
  (print "\nPrimes up to 20 (sieve):")
  (print (table.concat (sieve-of-eratosthenes 20) ", "))
  (print (.. "Is 17 prime? " (if (is-prime? 17) "Yes" "No")))
  (print (.. "Is 15 prime? " (if (is-prime? 15) "Yes" "No"))))

(run-examples)
#+END_SRC

** FizzBuzz

#+BEGIN_SRC fennel :tangle src/fennel/fizzbuzz.fnl :mkdirp yes
;; FizzBuzz implementation
(fn fizzbuzz [n]
  (for [i 1 n]
    (print (if (= (% i 15) 0) "FizzBuzz"
               (= (% i 3) 0) "Fizz"
               (= (% i 5) 0) "Buzz"
               i))))

;; FizzBuzz returning a table
(fn fizzbuzz-table [n]
  (local result [])
  (for [i 1 n]
    (table.insert result
                 (if (= (% i 15) 0) "FizzBuzz"
                     (= (% i 3) 0) "Fizz"
                     (= (% i 5) 0) "Buzz"
                     i)))
  result)

;; Example usage
(fn run-examples []
  (print "FizzBuzz (1-20):")
  (fizzbuzz 20)
  (print "\nFizzBuzz as table (1-20):")
  (local result (fizzbuzz-table 20))
  (var output "")
  (each [i v (ipairs result)]
    (set output (.. output v " ")))
  (print output))

(run-examples)
#+END_SRC

** Quicksort

#+BEGIN_SRC fennel :tangle src/fennel/quicksort.fnl :mkdirp yes
;; Quicksort implementation
(fn quicksort [arr]
  (if (or (= (length arr) 0) (= (length arr) 1))
      arr
      (let [pivot (. arr 1)
            lesser []
            greater []]
        (for [i 2 (length arr)]
          (let [value (. arr i)]
            (if (< value pivot)
                (table.insert lesser value)
                (table.insert greater value))))
        (let [result (quicksort lesser)]
          (table.insert result pivot)
          (each [_ v (ipairs (quicksort greater))]
            (table.insert result v))
          result))))

;; Example usage
(fn run-examples []
  (local numbers [3 1 4 1 5 9 2 6 5 3 5])
  (print "Original list:")
  (print (table.concat numbers ", "))
  (print "\nSorted list:")
  (print (table.concat (quicksort numbers) ", ")))

(run-examples)
#+END_SRC

* Janet

** Fibonacci

#+BEGIN_SRC janet :tangle src/janet/fibonacci.janet :mkdirp yes
# Recursive implementation
(defn fib-recursive [n]
  (cond
    (= n 0) 0
    (= n 1) 1
    (+ (fib-recursive (- n 1))
       (fib-recursive (- n 2)))))

# Memoized implementation
(defn fib-memo [n]
  (def cache @{})
  (defn fib [n]
    (if (get cache n)
      (get cache n)
      (let [result (if (< n 2)
                     n
                     (+ (fib (- n 1))
                        (fib (- n 2))))]
        (put cache n result)
        result)))
  (fib n))

# Tail-recursive implementation
(defn fib-tail [n]
  (defn fib-iter [a b count]
    (if (= count 0)
        a
        (fib-iter b (+ a b) (- count 1))))
  (fib-iter 0 1 n))

# Example usage
(defn run-examples []
  (printf "Fibonacci of 10 (recursive): %d" (fib-recursive 10))
  (printf "Fibonacci of 10 (memoized): %d" (fib-memo 10))
  (printf "Fibonacci of 10 (tail-recursive): %d" (fib-tail 10)))

(run-examples)
#+END_SRC

** Factorial

#+BEGIN_SRC janet :tangle src/janet/factorial.janet :mkdirp yes
# Recursive implementation
(defn factorial-recursive [n]
  (if (<= n 1)
    1
    (* n (factorial-recursive (- n 1)))))

# Tail-recursive implementation
(defn factorial-tail [n &opt acc]
  (default acc 1)
  (if (<= n 1)
    acc
    (factorial-tail (- n 1) (* n acc))))

# Iterative implementation
(defn factorial-iterative [n]
  (var result 1)
  (for i 1 (+ n 1)
    (set result (* result i)))
  result)

# Example usage
(defn run-examples []
  (printf "Factorial of 5 (recursive): %d" (factorial-recursive 5))
  (printf "Factorial of 5 (tail-recursive): %d" (factorial-tail 5))
  (printf "Factorial of 5 (iterative): %d" (factorial-iterative 5)))

(run-examples)
#+END_SRC

** Prime Number Generator

#+BEGIN_SRC janet :tangle src/janet/primes.janet :mkdirp yes
# Check if a number is prime
(defn prime? [n]
  (when (> n 1)
    (var is-prime true)
    (def limit (math/sqrt n))
    (for i 2 (+ (math/floor limit) 1)
      (when (= (% n i) 0)
        (set is-prime false)
        (break)))
    is-prime))

# Generate primes up to n
(defn primes-up-to [n]
  (def result @[])
  (for i 2 (+ n 1)
    (when (prime? i)
      (array/push result i)))
  result)

# Sieve of Eratosthenes
(defn sieve-of-eratosthenes [n]
  (def sieve (array/new-filled (+ n 1) true))
  # 0 and 1 are not prime
  (put sieve 0 false)
  (put sieve 1 false)
  
  (def limit (math/sqrt n))
  (for i 2 (+ (math/floor limit) 1)
    (when (get sieve i)
      (var j (* i i))
      (while (<= j n)
        (put sieve j false)
        (set j (+ j i)))))
  
  (def primes @[])
  (for i 2 (+ n 1)
    (when (get sieve i)
      (array/push primes i)))
  
  primes)

# Example usage
(defn run-examples []
  (printf "Primes up to 20: %j" (primes-up-to 20))
  (printf "Primes up to 20 (sieve): %j" (sieve-of-eratosthenes 20))
  (printf "Is 17 prime? %s" (if (prime? 17) "Yes" "No"))
  (printf "Is 15 prime? %s" (if (prime? 15) "Yes" "No")))

(run-examples)
#+END_SRC

** FizzBuzz

#+BEGIN_SRC janet :tangle src/janet/fizzbuzz.janet :mkdirp yes
# FizzBuzz implementation
(defn fizzbuzz [n]
  (for i 1 (+ n 1)
    (print (cond
             (= (% i 15) 0) "FizzBuzz"
             (= (% i 3) 0) "Fizz"
             (= (% i 5) 0) "Buzz"
             i))))

# FizzBuzz returning an array
(defn fizzbuzz-array [n]
  (def result @[])
  (for i 1 (+ n 1)
    (array/push result 
                (cond
                  (= (% i 15) 0) "FizzBuzz"
                  (= (% i 3) 0) "Fizz"
                  (= (% i 5) 0) "Buzz"
                  i)))
  result)

# Example usage
(defn run-examples []
  (print "FizzBuzz (1-20):")
  (fizzbuzz 20)
  (print "\nFizzBuzz as array (1-20):")
  (printf "%j" (fizzbuzz-array 20)))

(run-examples)
#+END_SRC

** Quicksort

#+BEGIN_SRC janet :tangle src/janet/quicksort.janet :mkdirp yes
# Quicksort implementation
(defn quicksort [arr]
  (if (or (= (length arr) 0) (= (length arr) 1))
    arr
    (let [pivot (first arr)
          rest (array/slice arr 1)
          lesser (filter |(< $ pivot) rest)
          greater (filter |(>= $ pivot) rest)]
      (array/concat (quicksort lesser) @[pivot] (quicksort greater)))))

# Example usage
(defn run-examples []
  (def numbers @[3 1 4 1 5 9 2 6 5 3 5])
  (printf "Original array: %j" numbers)
  (printf "Sorted array: %j" (quicksort numbers)))

(run-examples)
#+END_SRC
* Running Examples

** Common Lisp
#+BEGIN_SRC shell :tangle scripts/run-common-lisp.sh :mkdirp yes
#!/bin/sh
sbcl --load src/common-lisp/fibonacci.lisp --eval '(cl-fibonacci:run-examples)' --quit
sbcl --load src/common-lisp/factorial.lisp --eval '(cl-factorial:run-examples)' --quit
sbcl --load src/common-lisp/primes.lisp --eval '(cl-primes:run-examples)' --quit
sbcl --load src/common-lisp/fizzbuzz.lisp --eval '(cl-fizzbuzz:run-examples)' --quit
sbcl --load src/common-lisp/quicksort.lisp --eval '(cl-quicksort:run-examples)' --quit
#+END_SRC

** Clojure
#+BEGIN_SRC shell :tangle scripts/run-clojure.sh :mkdirp yes
#!/bin/sh
clj -M src/clojure/fibonacci.clj
clj -M src/clojure/factorial.clj
clj -M src/clojure/primes.clj
clj -M src/clojure/fizzbuzz.clj
clj -M src/clojure/quicksort.clj
#+END_SRC

** Scheme
#+BEGIN_SRC shell :tangle scripts/run-scheme.sh :mkdirp yes
#!/bin/sh
# Using Guile
guile src/scheme/fibonacci.scm
guile src/scheme/factorial.scm
guile src/scheme/primes.scm
guile src/scheme/fizzbuzz.scm
guile src/scheme/quicksort.scm
#+END_SRC

** Emacs Lisp
#+BEGIN_SRC shell :tangle scripts/run-emacs-lisp.sh :mkdirp yes
#!/bin/sh
emacs --batch \
  --load src/emacs-lisp/fibonacci.el \
  --load src/emacs-lisp/factorial.el \
  --load src/emacs-lisp/primes.el \
  --load src/emacs-lisp/fizzbuzz.el \
  --load src/emacs-lisp/quicksort.el \
  --eval "(progn (run-fibonacci-examples) (run-factorial-examples) (run-prime-examples) (run-fizzbuzz-examples) (run-quicksort-examples))"
#+END_SRC

** Racket
#+BEGIN_SRC shell :tangle scripts/run-racket.sh :mkdirp yes
#!/bin/sh
racket src/racket/fibonacci.rkt
racket src/racket/factorial.rkt
racket src/racket/primes.rkt
racket src/racket/fizzbuzz.rkt
racket src/racket/quicksort.rkt
#+END_SRC

** Hy
#+BEGIN_SRC shell :tangle scripts/run-hy.sh :mkdirp yes
#!/bin/sh
hy src/hy/fibonacci.hy
hy src/hy/factorial.hy
hy src/hy/primes.hy
hy src/hy/fizzbuzz.hy
hy src/hy/quicksort.hy
#+END_SRC

** Fennel
#+BEGIN_SRC shell :tangle scripts/run-fennel.sh :mkdirp yes
#!/bin/sh
fennel src/fennel/fibonacci.fnl
fennel src/fennel/factorial.fnl
fennel src/fennel/primes.fnl
fennel src/fennel/fizzbuzz.fnl
fennel src/fennel/quicksort.fnl
#+END_SRC

** Janet
#+BEGIN_SRC shell :tangle scripts/run-janet.sh :mkdirp yes
#!/bin/sh
janet src/janet/fibonacci.janet
janet src/janet/factorial.janet
janet src/janet/primes.janet
janet src/janet/fizzbuzz.janet
janet src/janet/quicksort.janet
#+END_SRC

* Benchmarks

#+BEGIN_SRC shell :tangle scripts/benchmark.sh :mkdirp yes :shebang #!/usr/bin/env bash
# Benchmark the Fibonacci implementations

echo "Benchmarking Fibonacci (n=30):"
echo "=============================="

# Common Lisp
echo "Common Lisp:"
time sbcl --noinform --eval "(defun fib (n) (if (< n 2) n (+ (fib (- n 1)) (fib (- n 2)))))" \
          --eval "(time (fib 30))" --eval "(quit)" 2>&1 | grep "Evaluation took"

# Clojure
echo "Clojure:"
time clojure -e "(defn fib [n] (if (< n 2) n (+ (fib (- n 1)) (fib (- n 2))))) (time (fib 30))"

# Scheme (Guile)
echo "Scheme (Guile):"
time guile -c "(define (fib n) (if (< n 2) n (+ (fib (- n 1)) (fib (- n 2))))) (fib 30)"

# Emacs Lisp
echo "Emacs Lisp:"
time emacs --batch --eval "(defun fib (n) (if (< n 2) n (+ (fib (- n 1)) (fib (- n 2))))) (fib 30)"

# Racket
echo "Racket:"
time racket -e "(define (fib n) (if (< n 2) n (+ (fib (- n 1)) (fib (- n 2))))) (fib 30)"

# Hy
echo "Hy:"
time hy -c "(defn fib [n] (if (< n 2) n (+ (fib (- n 1)) (fib (- n 2))))) (fib 30)"

# Fennel
echo "Fennel:"
time fennel -e "(fn fib [n] (if (< n 2) n (+ (fib (- n 1)) (fib (- n 2))))) (fib 30)"

# Janet
echo "Janet:"
time janet -e "(defn fib [n] (if (< n 2) n (+ (fib (- n 1)) (fib (- n 2))))) (fib 30)"
#+END_SRC

* Mermaid Diagram Example

This section shows how to use mermaid diagrams with the lisp-dialect showcase.

#+BEGIN_SRC mermaid :file images/lisp-family-tree.png :tangle docs/lisp-family-tree.mmd :mkdirp yes
graph TD
    Lisp[Lisp 1.5<br>1958] --> CommonLisp[Common Lisp<br>1984]
    Lisp --> Scheme[Scheme<br>1975]
    Lisp --> InterLisp[InterLisp<br>1967]
    Lisp --> MacLisp[MacLisp<br>1966]
    
    MacLisp --> ZetaLisp[ZetaLisp<br>1978]
    MacLisp --> CommonLisp
    ZetaLisp --> CommonLisp
    
    Scheme --> Racket[Racket<br>1995]
    CommonLisp --> EmacLisp[Emacs Lisp<br>1985]
    
    Scheme --> Clojure[Clojure<br>2007]
    
    Clojure --> Hy[Hy<br>2013]
    
    Lisp --> NewLisp[NewLisp<br>1991]
    Lisp --> Fennel[Fennel<br>2016]
    Lisp --> Janet[Janet<br>2017]
    
    style Lisp fill:#f9f,stroke:#333,stroke-width:4px
    style CommonLisp fill:#bbf,stroke:#333,stroke-width:4px
    style Scheme fill:#bfb,stroke:#333,stroke-width:4px
    style Clojure fill:#bbf,stroke:#333,stroke-width:3px
    style Racket fill:#fbf,stroke:#333,stroke-width:3px
    style EmacLisp fill:#fbf,stroke:#333,stroke-width:3px
    style Hy fill:#fbb,stroke:#333,stroke-width:2px
    style Fennel fill:#bff,stroke:#333,stroke-width:2px
    style Janet fill:#ffb,stroke:#333,stroke-width:2px
#+END_SRC
